/* ============================================================
   BLOCK 1 — GLOBAL CONSTANTS & STATE (DLB Telematics Studio Pro)
   ============================================================ */

const q = s => document.querySelector(s);
const toast = (msg, ms = 2200) => {
  const t = q('#toast');
  t.textContent = msg;
  t.style.display = 'block';
  setTimeout(() => (t.style.display = 'none'), ms);
};

/* --- Unit Conversion --- */
let displayUnit = "mph";
const MPH_PER_KPH = 0.621371;
const kphToDisplay = k => displayUnit === "mph" ? k * MPH_PER_KPH : k;
const displaySuffix = () => displayUnit === "mph" ? "mph" : "km/h";

/* --- Map + Layers --- */
let map;
let routeLayer, eventLayer, stopsLayer, gapLayer, impactLayer;
let drawnItems;               // geofence storage layer
let mover, trail;             // animated marker + path
let fenceDrawHandler, fenceEditHandler, fenceDeleteHandler;

/* --- Dataset --- */
let dataset = null;           // { points[], t0, t1, totalKm }
let maxSpeedKph = 0;

/* --- Playback --- */
let playing = false;
let rate = 1;
let playMs = 0;
let lastTs = 0;

/* --- Event Index (flattened list used for event panel) --- */
let eventsIndex = [];

/* --- Summary Cache --- */
let summaryCache = null;

/* --- Geofence Model --- */
let geofences = {
  type: "FeatureCollection",
  features: []
};

/* --- Helpers: Maths & Geo --- */
const toRad = d => d * Math.PI / 180;
const toDeg = r => r * 180 / Math.PI;
const degNorm = a => ((a % 360) + 360) % 360;

/* Haversine distance (km) */
function kmBetween(a, b) {
  const R = 6371;
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lon - a.lon);
  const la1 = toRad(a.lat), la2 = toRad(b.lat);
  const x = Math.sin(dLat/2)**2 +
            Math.cos(la1) * Math.cos(la2) * Math.sin(dLon/2)**2;
  return 2 * R * Math.asin(Math.min(1, Math.sqrt(x)));
}

/* Bearing (degrees) */
function bearing(a, b) {
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const dLon = toRad(b.lon - a.lon);
  const y = Math.sin(dLon) * Math.cos(lat2);
  const x = Math.cos(lat1)*Math.cos(lat2) - Math.sin(lat1)*Math.sin(lat2)*Math.cos(dLon);
  return degNorm(toDeg(Math.atan2(y, x)));
}

/* Deceleration / Acceleration colour system */
const speedToColor = (s, max) => {
  const p = Math.min(1, Math.max(0, (s||0) / (max||1)));
  const h = 210 - 210 * p;
  return `hsl(${h},80%,55%)`;
};
/* ============================================================
   BLOCK 2 — MAP ENGINE (DLB Telematics Studio Pro)
   ============================================================ */

function initMap() {

  /* -------------------------------
     1. Create Map Instance
     ------------------------------- */
  map = L.map("map", {
    zoomControl: true,
    preferCanvas: true,
    maxZoom: 20,
    minZoom: 2
  });

  /* -------------------------------
     2. Light Basemap (DLB Product Spec)
     ------------------------------- */
  const baseTiles = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution:
        '&copy; OpenStreetMap contributors',
      crossOrigin: true,
      maxNativeZoom: 19
    }
  ).addTo(map);

  /* -------------------------------
     3. Layer Architecture
     ------------------------------- */
  routeLayer        = L.layerGroup().addTo(map);
  eventLayer        = L.layerGroup().addTo(map);
  stopsLayer        = L.layerGroup().addTo(map);
  gapLayer          = L.layerGroup().addTo(map);
  impactLayer       = L.layerGroup().addTo(map);
  drawnItems        = new L.FeatureGroup().addTo(map);

  /* -------------------------------
     4. Vehicle Marker + Trail
     ------------------------------- */
  mover = L.circleMarker([51.5, -0.12], {
    radius: 8,
    weight: 2,
    color: "#ffffff",
    fillColor: "#ffffff",
    fillOpacity: 1
  }).addTo(map);

  trail = L.polyline([], {
    weight: 5,
    opacity: 0.9,
    color: "var(--brand)"
  }).addTo(map);

  map.setView([51.5, -0.12], 12);

  /* -------------------------------
     5. Fence Drawing Tools
     ------------------------------- */
  fenceDrawHandler = new L.Draw.Polygon(map, {
    shapeOptions: {
      color: "#94a3b8",
      weight: 2,
      fillOpacity: 0.08
    }
  });

  fenceEditHandler = new L.EditToolbar.Edit(map, {
    featureGroup: drawnItems
  });

  fenceDeleteHandler = new L.EditToolbar.Delete(map, {
    featureGroup: drawnItems
  });

  /* -------------------------------
     6. Load Stored Geofences
     ------------------------------- */
  try {
    const saved = localStorage.getItem("dlb.geofences.v1");
    if (saved) {
      geofences = JSON.parse(saved);
      renderFences();
    }
  } catch (e) {
    console.warn("Failed to load saved geofences:", e);
  }

  /* -------------------------------
     7. Fence Creation Event
     ------------------------------- */
  map.on(L.Draw.Event.CREATED, (e) => {
    const layer = e.layer;
    drawnItems.addLayer(layer);

    const gj = layer.toGeoJSON();
    const name =
      prompt(
        "Name this geofence:",
        "Fence " + (geofences.features.length + 1)
      ) ||
      "Fence " + (geofences.features.length + 1);

    gj.properties = { ...(gj.properties || {}), name };
    geofences.features.push(gj);

    persistFences();
    if (dataset) {
      detectFenceEvents(dataset);
      buildEventIndex();
      drawEvents();
      updateSummaryUI();
    }

    toast("Fence added: " + name);
  });

  /* -------------------------------
     8. Fence Edit/Delete Sync
     ------------------------------- */
  map.on(L.Draw.Event.EDITED, syncFencesFromLayers);
  map.on(L.Draw.Event.DELETED, syncFencesFromLayers);

  /* Map initialisation complete */
  console.log("DLB Map Engine: READY");
}


/* ============================================================
   FENCE SYNC HANDLER
   ============================================================ */
function syncFencesFromLayers() {
  geofences.features = [];

  drawnItems.eachLayer((layer) => {
    const gj = layer.toGeoJSON();
    if (!gj.properties) gj.properties = {};
    if (!gj.properties.name)
      gj.properties.name =
        "Fence " + (geofences.features.length + 1);

    geofences.features.push(gj);
  });

  persistFences();

  if (dataset) {
    detectFenceEvents(dataset);
    buildEventIndex();
    drawEvents();
    updateSummaryUI();
  }

  toast("Fences updated.");
}


/* ============================================================
   CALL INIT ON LOAD
   ============================================================ */
window.addEventListener("load", () => {
  try {
    initMap();
  } catch (e) {
    console.error("Map init failed:", e);
  }
});
/* ============================================================
   BLOCK 3 — DATA INGESTION + NORMALISATION
   - Handles CSV/XLSX using PapaParse + SheetJS (XLSX)
   - Normalises into { points, t0, t1, totalKm }
   - Computes speed, heading, turn rate, acceleration
   ============================================================ */

/**
 * Parse an uploaded telematics file (CSV / XLS / XLSX)
 * Returns an array of row objects (header → value).
 */
async function parseFile(file) {
  const ext = (file.name.split(".").pop() || "").toLowerCase();

  if (ext === "csv") {
    const text = await file.text();
    const parsed = Papa.parse(text, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });
    return parsed.data;
  }

  if (ext === "xlsx" || ext === "xls") {
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type: "array" });
    const ws = wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(ws, { defval: "" });
  }

  throw new Error("Unsupported file type: " + ext);
}


/**
 * Build a header map from various alias names.
 * Uses HEADER_ALIASES from Block 1.
 *
 * e.g. { timestamp: "Timestamp", lat: "Latitude", ... }
 */
function buildHeaderMap(headers) {
  const map = {};
  const lower = headers.map((h) => String(h || "").trim().toLowerCase());

  for (const [canon, aliases] of Object.entries(HEADER_ALIASES)) {
    for (let i = 0; i < lower.length; i++) {
      if (aliases.includes(lower[i])) {
        map[canon] = headers[i];
        break;
      }
    }
  }

  return map;
}


/**
 * Normalise raw row data into a derived telematics dataset.
 *
 * Returns:
 * {
 *   points: [
 *     {
 *       t,          // ms since epoch
 *       lat, lon,
 *       speedKph,
 *       events: [],
 *       km,        // distance from previous point (km)
 *       heading,   // bearing in degrees
 *       turnRate,  // deg/s
 *       acc        // m/s²
 *     }, ...
 *   ],
 *   t0, t1,        // start/end timestamps
 *   totalKm        // cumulative distance
 * }
 */
function normalizeRows(rows) {
  if (!rows || !rows.length) {
    return { points: [], t0: NaN, t1: NaN, totalKm: 0 };
  }

  // Build mapping from canonical → real header names
  const headerNames = Object.keys(rows[0]);
  const hm = buildHeaderMap(headerNames);

  if (!hm.timestamp || !hm.lat || !hm.lon || !hm.speed) {
    console.warn("Header map incomplete:", hm);
  }

  const points = [];

  for (const r of rows) {
    const lat = Number(r[hm.lat]);
    const lon = Number(r[hm.lon]);

    // Basic sanity on coords
    if (!isFinite(lat) || Math.abs(lat) > 90) continue;
    if (!isFinite(lon) || Math.abs(lon) > 180) continue;

    // Speed handling
    let sp = r[hm.speed];
    sp = (sp == null || sp === "") ? NaN : Number(sp);

    // If column header contains "mph", treat as mph and convert to kph
    const mphHeader = /mph/.test((hm.speed || "").toLowerCase());
    if (isFinite(sp) && mphHeader) sp *= 1.609344;

    // Timestamp normalisation via parseTs() from Block 1
    const t = parseTs(r[hm.timestamp]);

    // Extra event column (optional)
    const evRaw = String(r[hm.event] ?? "").toLowerCase().trim();
    const evs = evRaw ? evRaw.split(/[;,\s]+/).filter(Boolean) : [];

    points.push({
      t,
      lat,
      lon,
      speedKph: isFinite(sp) ? sp : NaN,
      events: evs
    });
  }

  if (!points.length) {
    return { points: [], t0: NaN, t1: NaN, totalKm: 0 };
  }

  // If all timestamps are NaN, synthesise 1s spacing
  if (points.every((p) => isNaN(p.t))) {
    const base = Date.now();
    points.forEach((p, i) => (p.t = base + i * 1000));
  }

  // Sort by time
  points.sort((a, b) => a.t - b.t);

  // Derive distance, heading, turn rate & acceleration
  for (let i = 1; i < points.length; i++) {
    const a = points[i - 1];
    const b = points[i];

    // Distance (km) using kmBetween() from Block 1
    b.km = kmBetween(a, b);

    // Heading (deg) using bearing() from Block 1
    b.heading = bearing(a, b);

    // Time delta (s)
    const dt = Math.max(0.001, (b.t - a.t) / 1000);

    // Turn rate (deg/s)
    const prevHeading = isFinite(a.heading) ? a.heading : b.heading;
    b.turnRate = Math.abs(degDelta(prevHeading, b.heading)) / dt;

    // Acceleration (m/s²) from speedKph
    const v1 = (isFinite(a.speedKph) ? a.speedKph : 0) / 3.6;
    const v2 = (isFinite(b.speedKph) ? b.speedKph : 0) / 3.6;
    b.acc = (v2 - v1) / dt;
  }

  // Interpolate missing speedKph values
  for (let i = 0; i < points.length; i++) {
    if (!isFinite(points[i].speedKph)) {
      let L = i - 1,
        R = i + 1,
        ls = null,
        rs = null;

      while (L >= 0 && !isFinite(points[L].speedKph)) L--;
      while (R < points.length && !isFinite(points[R].speedKph)) R++;

      if (L >= 0) ls = points[L].speedKph;
      if (R < points.length) rs = points[R].speedKph;

      points[i].speedKph =
        isFinite(ls) && isFinite(rs)
          ? (ls + rs) / 2
          : isFinite(ls)
          ? ls
          : isFinite(rs)
          ? rs
          : 0;
    }
  }

  // Update global max speed for colouring
  maxSpeedKph = points.reduce(
    (m, p) => Math.max(m, p.speedKph || 0),
    0
  );

  const t0 = points[0].t;
  const t1 = points[points.length - 1].t;
  const totalKm = points.reduce((s, p) => s + (p.km || 0), 0);

  return { points, t0, t1, totalKm };
}
        /* ============================================================
   BLOCK 4 — EVENT DETECTION ENGINE
   - Crash detection (ΔV-sensitive)
   - Harsh braking / Accel / Cornering
   - Time-gap analysis
   - Fence entry/exit
   - Dwells / Stops
   ============================================================ */


/* ------------------------------------------------------------
   1. Driving Behaviour Events
   ------------------------------------------------------------ */
function detectDrivingEvents(ds) {
  if (!ds || !ds.points || ds.points.length < 3) return;

  const pts = ds.points;

  // Thresholds tuned for telematics-style data
  const THR = {
    accelHard: 3.0,           // m/s², about 0.30g
    brakeHarsh: -4.5,         // m/s², about -0.45g
    crash: -7.5,              // m/s², about -0.75g (ΔV-based)
    turnRateHard: 45,         // deg/s
    minCornerSpeedKph: 25,    // low-speed corners ignored
    dwellMaxKph: 5,           // ≤5 kph = stationary
    dwellMinSec: 60,          // ≥60s = stop/dwell
    gapSec: 10                // ≥10s missing data = tamper/signal loss
  };

  // Reset auto-generated events
  pts.forEach((p) => {
    p.events = p.events.filter(
      (e) =>
        ![
          "accel_hard",
          "brake_harsh",
          "corner_hard",
          "crash",
          "gap",
          "stop"
        ].includes(e)
    );
  });

  /* --- Loop through points --- */
  for (let i = 1; i < pts.length; i++) {
    const a = pts[i - 1];
    const b = pts[i];

    const acc = b.acc || 0;
    const sp = b.speedKph || 0;
    const turn = b.turnRate || 0;

    /* --- Hard Acceleration --- */
    if (acc >= THR.accelHard) b.events.push("accel_hard");

    /* --- Harsh Braking --- */
    if (acc <= THR.brakeHarsh) b.events.push("brake_harsh");

    /* --- Crash / Impact Detection (ΔV > threshold) --- */
    if (acc <= THR.crash) b.events.push("crash");

    /* --- Hard Cornering --- */
    if (sp >= THR.minCornerSpeedKph && turn >= THR.turnRateHard)
      b.events.push("corner_hard");

    /* --- Time Gap Detection --- */
    const dt = (b.t - a.t) / 1000;
    if (dt >= THR.gapSec) b.events.push("gap:" + dt.toFixed(1));
  }

  /* --- After main loop, detect dwells/stops --- */
  detectDwells(ds, THR.dwellMaxKph, THR.dwellMinSec);
}


/* ------------------------------------------------------------
   2. Detect Dwells (Stops ≥ 60 seconds)
   ------------------------------------------------------------ */
function detectDwells(ds, maxKph = 5, minSec = 60) {
  const pts = ds.points;
  let i = 0;

  while (i < pts.length) {
    // Skip moving points
    while (i < pts.length && (pts[i].speedKph || 0) > maxKph) i++;
    if (i >= pts.length) break;

    // Now in stationary zone
    let j = i;
    let t0 = pts[i].t;

    // Continue until movement resumes
    while (j < pts.length && (pts[j].speedKph || 0) <= maxKph) j++;

    const t1 = pts[j - 1].t;
    const durSec = (t1 - t0) / 1000;

    if (durSec >= minSec) {
      const mid = Math.floor((i + j) / 2);
      pts[mid].events.push("stop:" + durSec.toFixed(0));
    }

    i = j + 1;
  }
}


/* ------------------------------------------------------------
   3. Geofence Entry / Exit Detection
   ------------------------------------------------------------ */
function detectFenceEvents(ds) {
  if (!geofences.features.length) return;
  const pts = ds.points;

  const polys = geofences.features.filter(
    (f) => f.geometry && /Polygon|MultiPolygon/.test(f.geometry.type)
  );
  if (!polys.length) return;

  for (let i = 1; i < pts.length; i++) {
    const a = pts[i - 1];
    const b = pts[i];

    const pa = turf.point([a.lon, a.lat]);
    const pb = turf.point([b.lon, b.lat]);

    for (const f of polys) {
      const name = f.properties?.name || "Zone";
      const ina = turf.booleanPointInPolygon(pa, f);
      const inb = turf.booleanPointInPolygon(pb, f);

      if (!ina && inb) b.events.push("enter:" + name);
      if (ina && !inb) b.events.push("exit:" + name);
    }
  }
}


/* ------------------------------------------------------------
   4. High-Level Wrapper — Called After Parsing
   ------------------------------------------------------------ */
function detectAllEvents(ds) {
  detectDrivingEvents(ds);
  detectFenceEvents(ds);
}
    /* ============================================================
   BLOCK 5 — RENDERING ENGINE
   - Route drawing (speed gradient)
   - Event markers
   - Crash pre-impact highlight (ΔV window)
   - Time-gaps visualisation
   - Dwells / stops
   - AOI-ready hooks (future)
   ============================================================ */


/* ------------------------------------------------------------
   1. Master Draw Function
   ------------------------------------------------------------ */
function drawAll(ds) {
  if (!ds || !ds.points || ds.points.length < 2) return;

  // Clear all layers
  routeLayer.clearLayers();
  eventLayer.clearLayers();
  stopsLayer.clearLayers();
  gapLayer.clearLayers();
  impactLayer.clearLayers();

  drawRoute(ds);
  drawEvents(ds);
  drawDiagnostics(ds);
}


/* ------------------------------------------------------------
   2. Route Drawing (speed-based colour)
   ------------------------------------------------------------ */
function drawRoute(ds) {
  const pts = ds.points;
  if (pts.length < 2) return;

  for (let i = 1; i < pts.length; i++) {
    const a = pts[i - 1];
    const b = pts[i];

    const avgSpeed = ((a.speedKph || 0) + (b.speedKph || 0)) / 2;

    L.polyline(
      [
        [a.lat, a.lon],
        [b.lat, b.lon]
      ],
      {
        weight: 5,
        opacity: 0.85,
        color: speedToColor(avgSpeed, maxSpeedKph)
      }
    ).addTo(routeLayer);
  }

  // Position vehicle at start
  mover.setLatLng([pts[0].lat, pts[0].lon]);
  trail.setLatLngs([[pts[0].lat, pts[0].lon]]);

  // Fit view
  const bounds = pts.map((p) => [p.lat, p.lon]);
  map.fitBounds(bounds, { padding: [25, 25] });
}


/* ------------------------------------------------------------
   3. Event Marker Layer (crash, brake, accel, corner, fence, gap)
   ------------------------------------------------------------ */
function drawEvents(ds) {
  const pts = ds.points;

  for (const p of pts) {
    const evs = p.events || [];
    const ll = [p.lat, p.lon];

    /* --- Always show CRASH prominently --- */
    if (evs.includes("crash")) {
      L.circleMarker(ll, {
        radius: 10,
        weight: 3,
        color: "var(--crash)",
        fillColor: "var(--crash)",
        fillOpacity: 0.9
      })
        .bindTooltip(
          new Date(p.t).toLocaleString() + " — CRASH",
          { direction: "top" }
        )
        .addTo(eventLayer);

      continue;
    }

    /* --- Skip if events turned off --- */
    if (!q("#chkEvents").checked) continue;

    for (const ev of evs) {
      let color = "#9ca3af";
      let label = ev;

      if (ev === "accel_hard") {
        color = "var(--ok)";
        label = "Hard Accel";
      } else if (ev === "brake_harsh") {
        color = "var(--bad)";
        label = "Harsh Brake";
      } else if (ev === "corner_hard") {
        color = "var(--vio)";
        label = "Hard Corner";
      } else if (ev.startsWith("enter:")) {
        color = "#38bdf8";
        label = ev.replace("enter:", "Enter: ");
      } else if (ev.startsWith("exit:")) {
        color = "#f59e0b";
        label = ev.replace("exit:", "Exit: ");
      } else if (ev.startsWith("gap:")) {
        color = "#f97316";
        label = "Gap (" + ev.split(":")[1] + "s)";
      } else if (ev.startsWith("stop:")) {
        color = "#0ea5e9";
        label = "Stop (" + ev.split(":")[1] + "s)";
      }

      L.circleMarker(ll, {
        radius: 6,
        weight: 2,
        color,
        fillColor: color,
        fillOpacity: 0.9
      })
        .bindTooltip(
          new Date(p.t).toLocaleString() + " — " + label,
          { direction: "top" }
        )
        .addTo(eventLayer);
    }
  }
}


/* ------------------------------------------------------------
   4. Diagnostics Layer (Gaps + Dwells)
   ------------------------------------------------------------ */
function drawDiagnostics(ds) {
  const pts = ds.points;

  for (let i = 1; i < pts.length; i++) {
    const a = pts[i - 1];
    const b = pts[i];

    const dt = (b.t - a.t) / 1000;

    /* --- Time Gap Segment --- */
    if (dt >= 10) {
      L.polyline(
        [
          [a.lat, a.lon],
          [b.lat, b.lon]
        ],
        {
          color: "#f97316",
          weight: 7,
          opacity: 1,
          dashArray: "6,4"
        }
      )
        .bindTooltip(`Time Gap: ${dt.toFixed(1)}s`)
        .addTo(gapLayer);
    }
  }

  /* --- Dwells (stops) --- */
  for (const p of pts) {
    const evStop = p.events.find((e) => e.startsWith("stop:"));
    if (!evStop) continue;

    const dur = evStop.split(":")[1];

    L.circleMarker([p.lat, p.lon], {
      radius: 8,
      weight: 2,
      color: "#38bdf8",
      fillColor: "#0ea5e9",
      fillOpacity: 0.85
    })
      .bindTooltip("Stop ~" + dur + "s")
      .addTo(stopsLayer);
  }
}


/* ------------------------------------------------------------
   5. Crash Pre-Impact Window (5 seconds)
   ------------------------------------------------------------ */
function highlightCrashWindow(eventObj) {
  if (!dataset) return;

  const pts = dataset.points;
  const tImpact = eventObj.t;
  const windowStart = tImpact - 5000;

  impactLayer.clearLayers();

  const startIdx = findIndex(pts, windowStart);
  const endIdx = findIndex(pts, tImpact);

  if (endIdx <= startIdx) return;

  const seg = [];
  for (let i = startIdx; i <= endIdx; i++) {
    seg.push([pts[i].lat, pts[i].lon]);
  }

  L.polyline(seg, {
    weight: 8,
    opacity: 1,
    color: "#ff365e"
  }).addTo(impactLayer);

  /* --- ΔV Estimate (basic) --- */
  const vA = (pts[startIdx].speedKph || 0) / 3.6;
  const vB = (pts[endIdx].speedKph || 0) / 3.6;
  const dV = Math.max(0, vA - vB);

  toast(
    `Pre-Impact Window (5s)\nEstimated ΔV: ${(dV * 2.23694).toFixed(1)} mph`
  );
}
    /* ============================================================
   BLOCK 6 — PLAYBACK, FILE I/O, WIRING, EXPORTS
   ============================================================ */

/* ------------------------------------------------------------
   1. Demo data
   ------------------------------------------------------------ */
function demoRows() {
  const base = Date.now();
  const list = [
    { t: base + 0,     lat: 51.505, lon: -0.09,  kph: 0  },
    { t: base + 4000,  lat: 51.506, lon: -0.088, kph: 18 },
    { t: base + 8000,  lat: 51.507, lon: -0.086, kph: 30 },
    { t: base + 12000, lat: 51.508, lon: -0.084, kph: 42 },
    { t: base + 16000, lat: 51.509, lon: -0.082, kph: 50 },
    { t: base + 22000, lat: 51.510, lon: -0.082, kph: 55 },
    { t: base + 28000, lat: 51.511, lon: -0.083, kph: 40 },
    { t: base + 34000, lat: 51.512, lon: -0.085, kph: 32 },
    { t: base + 40000, lat: 51.513, lon: -0.087, kph: 24 },
    { t: base + 46000, lat: 51.514, lon: -0.089, kph: 15 }
  ];
  return list.map(p => ({
    timestamp: new Date(p.t).toISOString(),
    lat: p.lat,
    lon: p.lon,
    speed: p.kph
  }));
}


/* ------------------------------------------------------------
   2. File parsing (CSV / XLSX)
   (Uses PapaParse & XLSX which are loaded via CDN)
   ------------------------------------------------------------ */
const parseFile = window.parseFile || async function (file) {
  const ext = (file.name.split(".").pop() || "").toLowerCase();

  if (ext === "csv") {
    const text = await file.text();
    const parsed = Papa.parse(text, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });
    return parsed.data;
  }

  if (ext === "xlsx" || ext === "xls") {
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type: "array" });
    const ws = wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(ws, { defval: "" });
  }

  throw new Error("Unsupported file type (use CSV / XLSX).");
};


/* ------------------------------------------------------------
   3. Dataset application glue
   (normalise → events → geofences → draw → stats → UI)
   ------------------------------------------------------------ */
function applyDataset(ds) {
  if (!ds || !ds.points || !ds.points.length) {
    toast("No usable points in dataset.");
    return;
  }

  dataset = ds;

  // Draw everything
  drawAll(ds);

  // Summary / stats / indices
  if (typeof updateStats === "function") {
    updateStats(ds);
  }
  if (typeof buildEventIndex === "function") {
    buildEventIndex();
  }
  if (typeof updateSummaryUI === "function") {
    updateSummaryUI();
  }

  // Enable playback controls
  q("#btnPlay").disabled = false;
  q("#btnPause").disabled = false;
  q("#scrub").disabled = false;
  q("#tCur").style.display = "inline-block";

  // Reset playback state
  playMs = ds.t0;
  lastTs = 0;
  q("#scrub").value = "0";

  // Hide centre overlay
  const centreBox = q("#centerBox");
  if (centreBox) centreBox.style.display = "none";
}


/* ------------------------------------------------------------
   4. Playback engine
   ------------------------------------------------------------ */
const findIndex = window.findIndex || function (points, t) {
  let lo = 0,
    hi = points.length - 1,
    mid;

  while (lo <= hi) {
    mid = (lo + hi) >> 1;
    if (points[mid].t === t) return mid;
    if (points[mid].t < t) lo = mid + 1;
    else hi = mid - 1;
  }

  return Math.max(0, Math.min(points.length - 2, lo - 1));
};

function setPlaying(isPlaying) {
  play = isPlaying;
  q("#btnPlay").disabled = isPlaying || !dataset;
  q("#btnPause").disabled = !isPlaying || !dataset;

  if (isPlaying && dataset) {
    lastTs = 0;
    requestAnimationFrame(tick);
  }
}

function tick(ts) {
  if (!play || !dataset) return;

  if (!lastTs) lastTs = ts;
  const dt = ts - lastTs;
  lastTs = ts;

  playMs += dt * rate;
  if (playMs >= dataset.t1) {
    playMs = dataset.t1;
    setPlaying(false);
  }

  const idx = findIndex(dataset.points, playMs);
  renderAt(idx, playMs);

  if (play) requestAnimationFrame(tick);
}

function lerp(a, b, p) {
  return a + (b - a) * p;
}

function renderAt(idx, t) {
  if (!dataset || !dataset.points.length) return;

  const pts = dataset.points;
  const a = pts[idx];
  const b = pts[Math.min(idx + 1, pts.length - 1)];

  const span = Math.max(1, b.t - a.t);
  const p = Math.min(1, Math.max(0, (t - a.t) / span));

  const lat = lerp(a.lat, b.lat, p);
  const lon = lerp(a.lon, b.lon, p);

  // Move vehicle
  mover.setLatLng([lat, lon]);
  mover.setStyle({
    color: speedToColor(lerp(a.speedKph || 0, b.speedKph || 0, p), maxSpeedKph)
  });

  // Follow map if enabled
  if (q("#chkFollow").checked) {
    map.panTo([lat, lon], { animate: false });
  }

  // Trail up to this point
  const upto = pts.slice(0, idx + 1).map(pt => [pt.lat, pt.lon]);
  if (upto.length) {
    upto.push([lat, lon]);
    trail.setStyle({ color: "var(--brand)" });
    trail.setLatLngs(upto);
  }

  // Scrubber and time
  const frac = (t - dataset.t0) / (dataset.t1 - dataset.t0 || 1);
  q("#scrub").value = String(Math.round(frac * 1000));
  q("#tCur").textContent = new Date(t).toLocaleTimeString();
}


/* ------------------------------------------------------------
   5. Drag-and-drop zone
   ------------------------------------------------------------ */
function enableDrop() {
  const box = document.getElementById("drop");
  if (!box) return;

  ["dragover", "dragenter"].forEach(ev =>
    box.addEventListener(ev, e => {
      e.preventDefault();
      box.style.borderColor = "var(--brand)";
    })
  );

  ["dragleave", "drop"].forEach(ev =>
    box.addEventListener(ev, e => {
      e.preventDefault();
      box.style.borderColor = "#2b3246";
    })
  );

  box.addEventListener("drop", async e => {
    const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
    if (!f) return;
    try {
      const rows = await parseFile(f);
      const ds = normalizeRows(rows);
      detectDrivingEvents(ds);
      detectFenceEvents(ds);
      applyDataset(ds);
      setPlaying(true);
    } catch (err) {
      console.error(err);
      toast("Could not read file: " + err.message);
    }
  });
}


/* ------------------------------------------------------------
   6. UI wiring
   ------------------------------------------------------------ */
document.addEventListener("DOMContentLoaded", () => {
  /* --- Dropzone --- */
  enableDrop();

  /* --- File buttons --- */
  const fileInput = q("#fileData");

  q("#btnPick").addEventListener("click", () => fileInput.click());
  q("#btnUpload").addEventListener("click", () => fileInput.click());

  fileInput.addEventListener("change", async e => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;

    try {
      const rows = await parseFile(f);
      const ds = normalizeRows(rows);
      detectDrivingEvents(ds);
      detectFenceEvents(ds);
      applyDataset(ds);
      setPlaying(true);
    } catch (err) {
      console.error(err);
      toast("Could not read file: " + err.message);
    } finally {
      e.target.value = "";
    }
  });

  /* --- Demo buttons --- */
  q("#btnQuickDemo").addEventListener("click", () => {
    const ds = normalizeRows(demoRows());
    detectDrivingEvents(ds);
    detectFenceEvents(ds);
    applyDataset(ds);
    setPlaying(true);
  });

  q("#btnDemo").addEventListener("click", () => {
    q("#btnQuickDemo").click();
  });

  /* --- Summary / Events panels --- */
  q("#btnSummaryPanel").addEventListener("click", () => {
    const p = q("#summaryPanel");
    p.style.display =
      p.style.display === "none" || !p.style.display ? "block" : "none";
  });

  q("#btnCloseSummary").addEventListener("click", () => {
    q("#summaryPanel").style.display = "none";
  });

  q("#btnEventsPanel").addEventListener("click", () => {
    const p = q("#eventsPanel");
    p.style.display =
      p.style.display === "none" || !p.style.display ? "block" : "none";
  });

  q("#btnClosePanel").addEventListener("click", () => {
    q("#eventsPanel").style.display = "none";
  });

  /* --- Event filters --- */
  ["fCrash", "fBrake", "fAccel", "fCorner", "fEnter", "fExit"].forEach(id => {
    const el = q("#" + id);
    if (!el) return;
    el.addEventListener("change", () => {
      if (typeof renderEventList === "function") renderEventList();
    });
  });

  /* --- Units & playback controls --- */
  q("#selUnits").addEventListener("change", e => {
    displayUnit = e.target.value;
    if (typeof updateStats === "function") updateStats(dataset);
    if (typeof renderEventList === "function") renderEventList();
    if (typeof updateSummaryUI === "function") updateSummaryUI();
    if (dataset) drawAll(dataset);
  });

  q("#btnPlay").addEventListener("click", () => setPlaying(true));
  q("#btnPause").addEventListener("click", () => setPlaying(false));

  q("#selRate").addEventListener("change", e => {
    rate = Number(e.target.value) || 1;
  });

  q("#chkEvents").addEventListener("change", () => {
    if (dataset) drawAll(dataset);
  });

  q("#scrub").addEventListener("input", e => {
    if (!dataset) return;
    const f = Number(e.target.value) / 1000;
    const t = dataset.t0 + f * (dataset.t1 - dataset.t0);
    playMs = t;
    const idx = findIndex(dataset.points, t);
    renderAt(idx, t);
  });

  /* --- Keyboard shortcuts --- */
  window.addEventListener("keydown", e => {
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;

    if (e.code === "Space") {
      e.preventDefault();
      if (!dataset) return;
      setPlaying(!play);
    } else if (e.code === "ArrowLeft" && dataset) {
      e.preventDefault();
      playMs = Math.max(dataset.t0, playMs - 1000);
      const idx = findIndex(dataset.points, playMs);
      renderAt(idx, playMs);
    } else if (e.code === "ArrowRight" && dataset) {
      e.preventDefault();
      playMs = Math.min(dataset.t1, playMs + 1000);
      const idx = findIndex(dataset.points, playMs);
      renderAt(idx, playMs);
    }
  });

  /* --- Export buttons --- */
  const btnExportEvents = q("#btnExportEvents");
  if (btnExportEvents && typeof exportEventsCSV === "function") {
    btnExportEvents.addEventListener("click", exportEventsCSV);
  }

  const btnExportSummary = q("#btnExportSummary");
  if (btnExportSummary) {
    btnExportSummary.addEventListener("click", () => {
      const s = typeof computeSummaryAndRisk === "function"
        ? computeSummaryAndRisk()
        : null;

      if (!s) {
        toast("Nothing to export yet.");
        return;
      }

      const header = [
        "distance_km",
        "duration_s",
        "avg_kph",
        "max_kph",
        "max_acc_mps2",
        "max_decel_mps2",
        "max_acc_g",
        "max_decel_g",
        "crash",
        "brake_harsh",
        "accel_hard",
        "corner_hard",
        "risk_score"
      ];

      const line = [
        s.distanceKm.toFixed(3),
        s.durationSec.toFixed(0),
        s.avgKph.toFixed(2),
        s.maxKph.toFixed(2),
        s.maxAcc.toFixed(3),
        s.maxDecel.toFixed(3),
        s.maxAccG.toFixed(3),
        s.maxDecelG.toFixed(3),
        s.counts.crash,
        s.counts.brake_harsh,
        s.counts.accel_hard,
        s.counts.corner_hard,
        s.risk.score.toFixed(1)
      ];

      const csv = [header.join(","), line.join(",")].join("\n");
      const a = document.createElement("a");
      a.href = URL.createObjectURL(
        new Blob([csv], { type: "text/csv;charset=utf-8;" })
      );
      a.download = "DLB_Summary.csv";
      a.click();
      URL.revokeObjectURL(a.href);
    });
  }
});
      /* ============================================================
   BLOCK 7 — FINAL BOOTSTRAP, GLOBAL FIXES, AND SAFE INITIALISATION
   ============================================================ */

/* ------------------------------------------------------------
   1. Ensure globals exist
   ------------------------------------------------------------ */

window.dataset = window.dataset || null;
window.map = window.map || null;

/* ------------------------------------------------------------
   2. Ensure drawAll() exists (fallback)
   ------------------------------------------------------------ */
if (typeof drawAll !== "function") {
  window.drawAll = function(ds) {
    if (!ds || !ds.points) return;

    if (typeof drawRoute === "function") drawRoute(ds);
    if (typeof drawEvents === "function") drawEvents();
  };
}

/* ------------------------------------------------------------
   3. Prevent double map initialisation
   ------------------------------------------------------------ */
if (!window._dlbMapInit) window._dlbMapInit = false;

function safeInitMap() {
  if (window._dlbMapInit) return;
  window._dlbMapInit = true;

  try {
    initMap();      // Your Block 1 map builder
  } catch (e) {
    console.error("Map failed initialisation:", e);
  }
}

/* ------------------------------------------------------------
   4. Boot once the DOM is ready & Leaflet is loaded
   ------------------------------------------------------------ */

function whenReady(fn) {
  if (document.readyState === "complete" || document.readyState === "interactive")
    return fn();
  document.addEventListener("DOMContentLoaded", fn);
}

function whenLeafletReady(fn) {
  if (window.L) return fn();
  const chk = setInterval(() => {
    if (window.L) {
      clearInterval(chk);
      fn();
    }
  }, 50);
}

whenReady(() =>
  whenLeafletReady(() => {
    safeInitMap();
  })
);

/* ------------------------------------------------------------
   5. Sanity guard — remove stray layers before use
   ------------------------------------------------------------ */
function cleanLayers() {
  try {
    if (!window.map) return;
    if (window.routeLayer && !map.hasLayer(routeLayer)) routeLayer.addTo(map);
    if (window.eventLayer && !map.hasLayer(eventLayer)) eventLayer.addTo(map);
    if (window.drawnItems && !map.hasLayer(drawnItems)) drawnItems.addTo(map);
  } catch (e) {
    console.warn("Layer cleanup skipped:", e);
  }
}

/* ------------------------------------------------------------
   6. High-frequency watchdog preventing “map undefined”
   ------------------------------------------------------------ */
setTimeout(cleanLayers, 300);
setTimeout(cleanLayers, 1500);
setTimeout(cleanLayers, 3000);

/* ------------------------------------------------------------
   7. Auto-recover playback after UI reloads
   ------------------------------------------------------------ */
document.addEventListener("visibilitychange", () => {
  if (!dataset || !map) return;

  // Fix leaflet viewport breaks after Chrome tab restore
  try {
    map.invalidateSize();
    if (trail) trail.redraw?.();
  } catch (e) {}

  // If tab was backgrounded while playing, resume smoothly
  if (play) {
    lastTs = 0;          // force synchronous tick restart
    requestAnimationFrame(tick);
  }
});

/* ------------------------------------------------------------
   8. Safe reflow when panels open/close
   ------------------------------------------------------------ */
["summaryPanel", "eventsPanel"].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;

  const observer = new MutationObserver(() => {
    try {
      if (map) map.invalidateSize();
    } catch (e) {}
  });

  observer.observe(el, { attributes: true, attributeFilter: ["style"] });
});
      
        
