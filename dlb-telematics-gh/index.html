/* ============================================================
   FAVICON SUPPRESSION FIX (GitHub Pages 404 prevention)
   This guarantees:
   - Browser will NOT request /favicon.ico
   - GitHub Pages cannot inject its broken link
   - No 404 errors in console
   ============================================================ */

(function fixFavicon404() {
    // Remove ANY favicon GitHub Pages injected
    document.querySelectorAll("link[rel='icon'], link[rel='shortcut icon']")
        .forEach(el => el.remove());

    // Create a transparent 1×1 PNG favicon (no requests made)
    const blankFavicon = document.createElement("link");
    blankFavicon.rel = "icon";
    blankFavicon.type = "image/png";
    blankFavicon.href =
        "data:image/png;base64," +
        "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";

    // Add it to HEAD safely
    const ensureHead = () => {
        if (document.head) {
            document.head.appendChild(blankFavicon);
        } else {
            // If DOM is still loading, try again after a short delay
            setTimeout(ensureHead, 30);
        }
    };
    ensureHead();
})();
/* ============================================================
   BLOCK 1 — GLOBAL CONSTANTS & STATE (DLB Telematics Studio Pro)
   ============================================================ */

const q = s => document.querySelector(s);
const toast = (msg, ms = 2200) => {
  const t = q('#toast');
  t.textContent = msg;
  t.style.display = 'block'; 
  setTimeout(() => (t.style.display = 'none'), ms);
};

/* --- Unit Conversion --- */
let displayUnit = "mph";
const MPH_PER_KPH = 0.621371;
const kphToDisplay = k => displayUnit === "mph" ? k * MPH_PER_KPH : k;
const displaySuffix = () => displayUnit === "mph" ? "mph" : "km/h";

/* --- Map + Layers --- */
let map;
let routeLayer, eventLayer, stopsLayer, gapLayer, impactLayer;
let drawnItems;               // geofence storage layer
let mover, trail;             // animated marker + path
let fenceDrawHandler, fenceEditHandler, fenceDeleteHandler;

/* --- Dataset --- */
let dataset = null;           // { points[], t0, t1, totalKm }
let maxSpeedKph = 0;

/* --- Playback --- */
let playing = false;
let rate = 1;
let playMs = 0;
let lastTs = 0;

/* --- Event Index (flattened list used for event panel) --- */
let eventsIndex = [];

/* --- Summary Cache --- */
let summaryCache = null;

/* --- Geofence Model --- */
let geofences = {
  type: "FeatureCollection",
  features: []
};

/* --- Helpers: Maths & Geo --- */
const toRad = d => d * Math.PI / 180;
const toDeg = r => r * 180 / Math.PI;
const degNorm = a => ((a % 360) + 360) % 360;

/* Haversine distance (km) */
function kmBetween(a, b) {
  const R = 6371;
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lon - a.lon);
  const la1 = toRad(a.lat), la2 = toRad(b.lat);
  const x = Math.sin(dLat/2)**2 +
            Math.cos(la1) * Math.cos(la2) * Math.sin(dLon/2)**2;
  return 2 * R * Math.asin(Math.min(1, Math.sqrt(x)));
}

/* Bearing (degrees) */
function bearing(a, b) {
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const dLon = toRad(b.lon - a.lon);
  const y = Math.sin(dLon) * Math.cos(lat2);
  const x = Math.cos(lat1)*Math.cos(lat2) - Math.sin(lat1)*Math.sin(lat2)*Math.cos(dLon);
  return degNorm(toDeg(Math.atan2(y, x)));
}

/* Deceleration / Acceleration colour system */
const speedToColor = (s, max) => {
  const p = Math.min(1, Math.max(0, (s||0) / (max||1)));
  const h = 210 - 210 * p;
  return `hsl(${h},80%,55%)`;
};
/* ============================================================
   BLOCK 2 — MAP ENGINE (DLB Telematics Studio Pro)
   ============================================================ */

function initMap() {

  /* -------------------------------
     1. Create Map Instance
     ------------------------------- */
  map = L.map("map", {
    zoomControl: true,
    preferCanvas: true,
    maxZoom: 20,
    minZoom: 2
  });

  /* -------------------------------
     2. Light Basemap (DLB Product Spec)
     ------------------------------- */
  const baseTiles = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution:
        '&copy; OpenStreetMap contributors',
      crossOrigin: true,
      maxNativeZoom: 19
    }
  ).addTo(map);

  /* -------------------------------
     3. Layer Architecture
     ------------------------------- */
  routeLayer        = L.layerGroup().addTo(map);
  eventLayer        = L.layerGroup().addTo(map);
  stopsLayer        = L.layerGroup().addTo(map);
  gapLayer          = L.layerGroup().addTo(map);
  impactLayer       = L.layerGroup().addTo(map);
  drawnItems        = new L.FeatureGroup().addTo(map);

  /* -------------------------------
     4. Vehicle Marker + Trail
     ------------------------------- */
  mover = L.circleMarker([51.5, -0.12], {
    radius: 8,
    weight: 2,
    color: "#ffffff",
    fillColor: "#ffffff",
    fillOpacity: 1
  }).addTo(map);

  trail = L.polyline([], {
    weight: 5,
    opacity: 0.9,
    color: "var(--brand)"
  }).addTo(map);

  map.setView([51.5, -0.12], 12);

  /* -------------------------------
     5. Fence Drawing Tools
     ------------------------------- */
  fenceDrawHandler = new L.Draw.Polygon(map, {
    shapeOptions: {
      color: "#94a3b8",
      weight: 2,
      fillOpacity: 0.08
    }
  });

  fenceEditHandler = new L.EditToolbar.Edit(map, {
    featureGroup: drawnItems
  });

  fenceDeleteHandler = new L.EditToolbar.Delete(map, {
    featureGroup: drawnItems
  });

  /* -------------------------------
     6. Load Stored Geofences
     ------------------------------- */
  try {
    const saved = localStorage.getItem("dlb.geofences.v1");
    if (saved) {
      geofences = JSON.parse(saved);
      renderFences();
    }
  } catch (e) {
    console.warn("Failed to load saved geofences:", e);
  }

  /* -------------------------------
     7. Fence Creation Event
     ------------------------------- */
  map.on(L.Draw.Event.CREATED, (e) => {
    const layer = e.layer;
    drawnItems.addLayer(layer);

    const gj = layer.toGeoJSON();
    const name =
      prompt(
        "Name this geofence:",
        "Fence " + (geofences.features.length + 1)
      ) ||
      "Fence " + (geofences.features.length + 1);

    gj.properties = { ...(gj.properties || {}), name };
    geofences.features.push(gj);

    persistFences();
    if (dataset) {
      detectFenceEvents(dataset);
      buildEventIndex();
      drawEvents();
      updateSummaryUI();
    }

    toast("Fence added: " + name);
  });

  /* -------------------------------
     8. Fence Edit/Delete Sync
     ------------------------------- */
  map.on(L.Draw.Event.EDITED, syncFencesFromLayers);
  map.on(L.Draw.Event.DELETED, syncFencesFromLayers);

  /* Map initialisation complete */
  console.log("DLB Map Engine: READY");
}


/* ============================================================
   FENCE SYNC HANDLER
   ============================================================ */
function syncFencesFromLayers() {
  geofences.features = [];

  drawnItems.eachLayer((layer) => {
    const gj = layer.toGeoJSON();
    if (!gj.properties) gj.properties = {};
    if (!gj.properties.name)
      gj.properties.name =
        "Fence " + (geofences.features.length + 1);

    geofences.features.push(gj);
  });

  persistFences();

  if (dataset) {
    detectFenceEvents(dataset);
    buildEventIndex();
    drawEvents();
    updateSummaryUI();
  }

  toast("Fences updated.");
}


/* ============================================================
   CALL INIT ON LOAD
   ============================================================ */
window.addEventListener("load", () => {
  try {
    initMap();
  } catch (e) {
    console.error("Map init failed:", e);
  }
});
/* ============================================================
   BLOCK 3 — DATA INGESTION + NORMALISATION
   - Handles CSV/XLSX using PapaParse + SheetJS (XLSX)
   - Normalises into { points, t0, t1, totalKm }
   - Computes speed, heading, turn rate, acceleration
   ============================================================ */

/**
 * Parse an uploaded telematics file (CSV / XLS / XLSX)
 * Returns an array of row objects (header → value).
 */
async function parseFile(file) {
  const ext = (file.name.split(".").pop() || "").toLowerCase();

  if (ext === "csv") {
    const text = await file.text();
    const parsed = Papa.parse(text, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });
    return parsed.data;
  }

  if (ext === "xlsx" || ext === "xls") {
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type: "array" });
    const ws = wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(ws, { defval: "" });
  }

  throw new Error("Unsupported file type: " + ext);
}


/**
 * Build a header map from various alias names.
 * Uses HEADER_ALIASES from Block 1.
 *
 * e.g. { timestamp: "Timestamp", lat: "Latitude", ... }
 */
function buildHeaderMap(headers) {
  const map = {};
  const lower = headers.map((h) => String(h || "").trim().toLowerCase());

  for (const [canon, aliases] of Object.entries(HEADER_ALIASES)) {
    for (let i = 0; i < lower.length; i++) {
      if (aliases.includes(lower[i])) {
        map[canon] = headers[i];
        break;
      }
    }
  }

  return map;
}


/**
 * Normalise raw row data into a derived telematics dataset.
 *
 * Returns:
 * {
 *   points: [
 *     {
 *       t,          // ms since epoch
 *       lat, lon,
 *       speedKph,
 *       events: [],
 *       km,        // distance from previous point (km)
 *       heading,   // bearing in degrees
 *       turnRate,  // deg/s
 *       acc        // m/s²
 *     }, ...
 *   ],
 *   t0, t1,        // start/end timestamps
 *   totalKm        // cumulative distance
 * }
 */
function normalizeRows(rows) {
  if (!rows || !rows.length) {
    return { points: [], t0: NaN, t1: NaN, totalKm: 0 };
  }

  // Build mapping from canonical → real header names
  const headerNames = Object.keys(rows[0]);
  const hm = buildHeaderMap(headerNames);

  if (!hm.timestamp || !hm.lat || !hm.lon || !hm.speed) {
    console.warn("Header map incomplete:", hm);
  }

  const points = [];

  for (const r of rows) {
    const lat = Number(r[hm.lat]);
    const lon = Number(r[hm.lon]);

    // Basic sanity on coords
    if (!isFinite(lat) || Math.abs(lat) > 90) continue;
    if (!isFinite(lon) || Math.abs(lon) > 180) continue;

    // Speed handling
    let sp = r[hm.speed];
    sp = (sp == null || sp === "") ? NaN : Number(sp);

    // If column header contains "mph", treat as mph and convert to kph
    const mphHeader = /mph/.test((hm.speed || "").toLowerCase());
    if (isFinite(sp) && mphHeader) sp *= 1.609344;

    // Timestamp normalisation via parseTs() from Block 1
    const t = parseTs(r[hm.timestamp]);

    // Extra event column (optional)
    const evRaw = String(r[hm.event] ?? "").toLowerCase().trim();
    const evs = evRaw ? evRaw.split(/[;,\s]+/).filter(Boolean) : [];

    points.push({
      t,
      lat,
      lon,
      speedKph: isFinite(sp) ? sp : NaN,
      events: evs
    });
  }

  if (!points.length) {
    return { points: [], t0: NaN, t1: NaN, totalKm: 0 };
  }

  // If all timestamps are NaN, synthesise 1s spacing
  if (points.every((p) => isNaN(p.t))) {
    const base = Date.now();
    points.forEach((p, i) => (p.t = base + i * 1000));
  }

  // Sort by time
  points.sort((a, b) => a.t - b.t);

  // Derive distance, heading, turn rate & acceleration
  for (let i = 1; i < points.length; i++) {
    const a = points[i - 1];
    const b = points[i];

    // Distance (km) using kmBetween() from Block 1
    b.km = kmBetween(a, b);

    // Heading (deg) using bearing() from Block 1
    b.heading = bearing(a, b);

    // Time delta (s)
    const dt = Math.max(0.001, (b.t - a.t) / 1000);

    // Turn rate (deg/s)
    const prevHeading = isFinite(a.heading) ? a.heading : b.heading;
    b.turnRate = Math.abs(degDelta(prevHeading, b.heading)) / dt;

    // Acceleration (m/s²) from speedKph
    const v1 = (isFinite(a.speedKph) ? a.speedKph : 0) / 3.6;
    const v2 = (isFinite(b.speedKph) ? b.speedKph : 0) / 3.6;
    b.acc = (v2 - v1) / dt;
  }

  // Interpolate missing speedKph values
  for (let i = 0; i < points.length; i++) {
    if (!isFinite(points[i].speedKph)) {
      let L = i - 1,
        R = i + 1,
        ls = null,
        rs = null;

      while (L >= 0 && !isFinite(points[L].speedKph)) L--;
      while (R < points.length && !isFinite(points[R].speedKph)) R++;

      if (L >= 0) ls = points[L].speedKph;
      if (R < points.length) rs = points[R].speedKph;

      points[i].speedKph =
        isFinite(ls) && isFinite(rs)
          ? (ls + rs) / 2
          : isFinite(ls)
          ? ls
          : isFinite(rs)
          ? rs
          : 0;
    }
  }

  // Update global max speed for colouring
  maxSpeedKph = points.reduce(
    (m, p) => Math.max(m, p.speedKph || 0),
    0
  );

  const t0 = points[0].t;
  const t1 = points[points.length - 1].t;
  const totalKm = points.reduce((s, p) => s + (p.km || 0), 0);

  return { points, t0, t1, totalKm };
}
        /* ============================================================
   BLOCK 4 — EVENT DETECTION ENGINE
   - Crash detection (ΔV-sensitive)
   - Harsh braking / Accel / Cornering
   - Time-gap analysis
   - Fence entry/exit
   - Dwells / Stops
   ============================================================ */


/* ------------------------------------------------------------
   1. Driving Behaviour Events
   ------------------------------------------------------------ */
function detectDrivingEvents(ds) {
  if (!ds || !ds.points || ds.points.length < 3) return;

  const pts = ds.points;

  // Thresholds tuned for telematics-style data
  const THR = {
    accelHard: 3.0,           // m/s², about 0.30g
    brakeHarsh: -4.5,         // m/s², about -0.45g
    crash: -7.5,              // m/s², about -0.75g (ΔV-based)
    turnRateHard: 45,         // deg/s
    minCornerSpeedKph: 25,    // low-speed corners ignored
    dwellMaxKph: 5,           // ≤5 kph = stationary
    dwellMinSec: 60,          // ≥60s = stop/dwell
    gapSec: 10                // ≥10s missing data = tamper/signal loss
  };

  // Reset auto-generated events
  pts.forEach((p) => {
    p.events = p.events.filter(
      (e) =>
        ![
          "accel_hard",
          "brake_harsh",
          "corner_hard",
          "crash",
          "gap",
          "stop"
        ].includes(e)
    );
  });

  /* --- Loop through points --- */
  for (let i = 1; i < pts.length; i++) {
    const a = pts[i - 1];
    const b = pts[i];

    const acc = b.acc || 0;
    const sp = b.speedKph || 0;
    const turn = b.turnRate || 0;

    /* --- Hard Acceleration --- */
    if (acc >= THR.accelHard) b.events.push("accel_hard");

    /* --- Harsh Braking --- */
    if (acc <= THR.brakeHarsh) b.events.push("brake_harsh");

    /* --- Crash / Impact Detection (ΔV > threshold) --- */
    if (acc <= THR.crash) b.events.push("crash");

    /* --- Hard Cornering --- */
    if (sp >= THR.minCornerSpeedKph && turn >= THR.turnRateHard)
      b.events.push("corner_hard");

    /* --- Time Gap Detection --- */
    const dt = (b.t - a.t) / 1000;
    if (dt >= THR.gapSec) b.events.push("gap:" + dt.toFixed(1));
  }

  /* --- After main loop, detect dwells/stops --- */
  detectDwells(ds, THR.dwellMaxKph, THR.dwellMinSec);
}


/* ------------------------------------------------------------
   2. Detect Dwells (Stops ≥ 60 seconds)
   ------------------------------------------------------------ */
function detectDwells(ds, maxKph = 5, minSec = 60) {
  const pts = ds.points;
  let i = 0;

  while (i < pts.length) {
    // Skip moving points
    while (i < pts.length && (pts[i].speedKph || 0) > maxKph) i++;
    if (i >= pts.length) break;

    // Now in stationary zone
    let j = i;
    let t0 = pts[i].t;

    // Continue until movement resumes
    while (j < pts.length && (pts[j].speedKph || 0) <= maxKph) j++;

    const t1 = pts[j - 1].t;
    const durSec = (t1 - t0) / 1000;

    if (durSec >= minSec) {
      const mid = Math.floor((i + j) / 2);
      pts[mid].events.push("stop:" + durSec.toFixed(0));
    }

    i = j + 1;
  }
}


/* ------------------------------------------------------------
   3. Geofence Entry / Exit Detection
   ------------------------------------------------------------ */
function detectFenceEvents(ds) {
  if (!geofences.features.length) return;
  const pts = ds.points;

  const polys = geofences.features.filter(
    (f) => f.geometry && /Polygon|MultiPolygon/.test(f.geometry.type)
  );
  if (!polys.length) return;

  for (let i = 1; i < pts.length; i++) {
    const a = pts[i - 1];
    const b = pts[i];

    const pa = turf.point([a.lon, a.lat]);
    const pb = turf.point([b.lon, b.lat]);

    for (const f of polys) {
      const name = f.properties?.name || "Zone";
      const ina = turf.booleanPointInPolygon(pa, f);
      const inb = turf.booleanPointInPolygon(pb, f);

      if (!ina && inb) b.events.push("enter:" + name);
      if (ina && !inb) b.events.push("exit:" + name);
    }
  }
}


/* ------------------------------------------------------------
   4. High-Level Wrapper — Called After Parsing
   ------------------------------------------------------------ */
function detectAllEvents(ds) {
  detectDrivingEvents(ds);
  detectFenceEvents(ds);
}
    /* ============================================================
   BLOCK 5 — RENDERING ENGINE
   - Route drawing (speed gradient)
   - Event markers
   - Crash pre-impact highlight (ΔV window)
   - Time-gaps visualisation
   - Dwells / stops
   - AOI-ready hooks (future)
   ============================================================ */


/* ------------------------------------------------------------
   1. Master Draw Function
   ------------------------------------------------------------ */
function drawAll(ds) {
  if (!ds || !ds.points || ds.points.length < 2) return;

  // Clear all layers
  routeLayer.clearLayers();
  eventLayer.clearLayers();
  stopsLayer.clearLayers();
  gapLayer.clearLayers();
  impactLayer.clearLayers();

  drawRoute(ds);
  drawEvents(ds);
  drawDiagnostics(ds);
}


/* ------------------------------------------------------------
   2. Route Drawing (speed-based colour)
   ------------------------------------------------------------ */
function drawRoute(ds) {
  const pts = ds.points;
  if (pts.length < 2) return;

  for (let i = 1; i < pts.length; i++) {
    const a = pts[i - 1];
    const b = pts[i];

    const avgSpeed = ((a.speedKph || 0) + (b.speedKph || 0)) / 2;

    L.polyline(
      [
        [a.lat, a.lon],
        [b.lat, b.lon]
      ],
      {
        weight: 5,
        opacity: 0.85,
        color: speedToColor(avgSpeed, maxSpeedKph)
      }
    ).addTo(routeLayer);
  }

  // Position vehicle at start
  mover.setLatLng([pts[0].lat, pts[0].lon]);
  trail.setLatLngs([[pts[0].lat, pts[0].lon]]);

  // Fit view
  const bounds = pts.map((p) => [p.lat, p.lon]);
  map.fitBounds(bounds, { padding: [25, 25] });
}


/* ------------------------------------------------------------
   3. Event Marker Layer (crash, brake, accel, corner, fence, gap)
   ------------------------------------------------------------ */
function drawEvents(ds) {
  const pts = ds.points;

  for (const p of pts) {
    const evs = p.events || [];
    const ll = [p.lat, p.lon];

    /* --- Always show CRASH prominently --- */
    if (evs.includes("crash")) {
      L.circleMarker(ll, {
        radius: 10,
        weight: 3,
        color: "var(--crash)",
        fillColor: "var(--crash)",
        fillOpacity: 0.9
      })
        .bindTooltip(
          new Date(p.t).toLocaleString() + " — CRASH",
          { direction: "top" }
        )
        .addTo(eventLayer);

      continue;
    }

    /* --- Skip if events turned off --- */
    if (!q("#chkEvents").checked) continue;

    for (const ev of evs) {
      let color = "#9ca3af";
      let label = ev;

      if (ev === "accel_hard") {
        color = "var(--ok)";
        label = "Hard Accel";
      } else if (ev === "brake_harsh") {
        color = "var(--bad)";
        label = "Harsh Brake";
      } else if (ev === "corner_hard") {
        color = "var(--vio)";
        label = "Hard Corner";
      } else if (ev.startsWith("enter:")) {
        color = "#38bdf8";
        label = ev.replace("enter:", "Enter: ");
      } else if (ev.startsWith("exit:")) {
        color = "#f59e0b";
        label = ev.replace("exit:", "Exit: ");
      } else if (ev.startsWith("gap:")) {
        color = "#f97316";
        label = "Gap (" + ev.split(":")[1] + "s)";
      } else if (ev.startsWith("stop:")) {
        color = "#0ea5e9";
        label = "Stop (" + ev.split(":")[1] + "s)";
      }

      L.circleMarker(ll, {
        radius: 6,
        weight: 2,
        color,
        fillColor: color,
        fillOpacity: 0.9
      })
        .bindTooltip(
          new Date(p.t).toLocaleString() + " — " + label,
          { direction: "top" }
        )
        .addTo(eventLayer);
    }
  }
}


/* ------------------------------------------------------------
   4. Diagnostics Layer (Gaps + Dwells)
   ------------------------------------------------------------ */
function drawDiagnostics(ds) {
  const pts = ds.points;

  for (let i = 1; i < pts.length; i++) {
    const a = pts[i - 1];
    const b = pts[i];

    const dt = (b.t - a.t) / 1000;

    /* --- Time Gap Segment --- */
    if (dt >= 10) {
      L.polyline(
        [
          [a.lat, a.lon],
          [b.lat, b.lon]
        ],
        {
          color: "#f97316",
          weight: 7,
          opacity: 1,
          dashArray: "6,4"
        }
      )
        .bindTooltip(`Time Gap: ${dt.toFixed(1)}s`)
        .addTo(gapLayer);
    }
  }

  /* --- Dwells (stops) --- */
  for (const p of pts) {
    const evStop = p.events.find((e) => e.startsWith("stop:"));
    if (!evStop) continue;

    const dur = evStop.split(":")[1];

    L.circleMarker([p.lat, p.lon], {
      radius: 8,
      weight: 2,
      color: "#38bdf8",
      fillColor: "#0ea5e9",
      fillOpacity: 0.85
    })
      .bindTooltip("Stop ~" + dur + "s")
      .addTo(stopsLayer);
  }
}


/* ------------------------------------------------------------
   5. Crash Pre-Impact Window (5 seconds)
   ------------------------------------------------------------ */
function highlightCrashWindow(eventObj) {
  if (!dataset) return;

  const pts = dataset.points;
  const tImpact = eventObj.t;
  const windowStart = tImpact - 5000;

  impactLayer.clearLayers();

  const startIdx = findIndex(pts, windowStart);
  const endIdx = findIndex(pts, tImpact);

  if (endIdx <= startIdx) return;

  const seg = [];
  for (let i = startIdx; i <= endIdx; i++) {
    seg.push([pts[i].lat, pts[i].lon]);
  }

  L.polyline(seg, {
    weight: 8,
    opacity: 1,
    color: "#ff365e"
  }).addTo(impactLayer);

  /* --- ΔV Estimate (basic) --- */
  const vA = (pts[startIdx].speedKph || 0) / 3.6;
  const vB = (pts[endIdx].speedKph || 0) / 3.6;
  const dV = Math.max(0, vA - vB);

  toast(
    `Pre-Impact Window (5s)\nEstimated ΔV: ${(dV * 2.23694).toFixed(1)} mph`
  );
}
    /* ============================================================
   BLOCK 6 — PLAYBACK, FILE I/O, WIRING, EXPORTS
   ============================================================ */

/* ------------------------------------------------------------
   1. Demo data
   ------------------------------------------------------------ */
function demoRows() {
  const base = Date.now();
  const list = [
    { t: base + 0,     lat: 51.505, lon: -0.09,  kph: 0  },
    { t: base + 4000,  lat: 51.506, lon: -0.088, kph: 18 },
    { t: base + 8000,  lat: 51.507, lon: -0.086, kph: 30 },
    { t: base + 12000, lat: 51.508, lon: -0.084, kph: 42 },
    { t: base + 16000, lat: 51.509, lon: -0.082, kph: 50 },
    { t: base + 22000, lat: 51.510, lon: -0.082, kph: 55 },
    { t: base + 28000, lat: 51.511, lon: -0.083, kph: 40 },
    { t: base + 34000, lat: 51.512, lon: -0.085, kph: 32 },
    { t: base + 40000, lat: 51.513, lon: -0.087, kph: 24 },
    { t: base + 46000, lat: 51.514, lon: -0.089, kph: 15 }
  ];
  return list.map(p => ({
    timestamp: new Date(p.t).toISOString(),
    lat: p.lat,
    lon: p.lon,
    speed: p.kph
  }));
}


/* ------------------------------------------------------------
   2. File parsing (CSV / XLSX)
   (Uses PapaParse & XLSX which are loaded via CDN)
   ------------------------------------------------------------ */
const parseFile = window.parseFile || async function (file) {
  const ext = (file.name.split(".").pop() || "").toLowerCase();

  if (ext === "csv") {
    const text = await file.text();
    const parsed = Papa.parse(text, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });
    return parsed.data;
  }

  if (ext === "xlsx" || ext === "xls") {
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type: "array" });
    const ws = wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(ws, { defval: "" });
  }

  throw new Error("Unsupported file type (use CSV / XLSX).");
};


/* ------------------------------------------------------------
   3. Dataset application glue
   (normalise → events → geofences → draw → stats → UI)
   ------------------------------------------------------------ */
function applyDataset(ds) {
  if (!ds || !ds.points || !ds.points.length) {
    toast("No usable points in dataset.");
    return;
  }

  dataset = ds;

  // Draw everything
  drawAll(ds);

  // Summary / stats / indices
  if (typeof updateStats === "function") {
    updateStats(ds);
  }
  if (typeof buildEventIndex === "function") {
    buildEventIndex();
  }
  if (typeof updateSummaryUI === "function") {
    updateSummaryUI();
  }

  // Enable playback controls
  q("#btnPlay").disabled = false;
  q("#btnPause").disabled = false;
  q("#scrub").disabled = false;
  q("#tCur").style.display = "inline-block";

  // Reset playback state
  playMs = ds.t0;
  lastTs = 0;
  q("#scrub").value = "0";

  // Hide centre overlay
  const centreBox = q("#centerBox");
  if (centreBox) centreBox.style.display = "none";
}


/* ------------------------------------------------------------
   4. Playback engine
   ------------------------------------------------------------ */
const findIndex = window.findIndex || function (points, t) {
  let lo = 0,
    hi = points.length - 1,
    mid;

  while (lo <= hi) {
    mid = (lo + hi) >> 1;
    if (points[mid].t === t) return mid;
    if (points[mid].t < t) lo = mid + 1;
    else hi = mid - 1;
  }

  return Math.max(0, Math.min(points.length - 2, lo - 1));
};

function setPlaying(isPlaying) {
  play = isPlaying;
  q("#btnPlay").disabled = isPlaying || !dataset;
  q("#btnPause").disabled = !isPlaying || !dataset;

  if (isPlaying && dataset) {
    lastTs = 0;
    requestAnimationFrame(tick);
  }
}

function tick(ts) {
  if (!play || !dataset) return;

  if (!lastTs) lastTs = ts;
  const dt = ts - lastTs;
  lastTs = ts;

  playMs += dt * rate;
  if (playMs >= dataset.t1) {
    playMs = dataset.t1;
    setPlaying(false);
  }

  const idx = findIndex(dataset.points, playMs);
  renderAt(idx, playMs);

  if (play) requestAnimationFrame(tick);
}

function lerp(a, b, p) {
  return a + (b - a) * p;
}

function renderAt(idx, t) {
  if (!dataset || !dataset.points.length) return;

  const pts = dataset.points;
  const a = pts[idx];
  const b = pts[Math.min(idx + 1, pts.length - 1)];

  const span = Math.max(1, b.t - a.t);
  const p = Math.min(1, Math.max(0, (t - a.t) / span));

  const lat = lerp(a.lat, b.lat, p);
  const lon = lerp(a.lon, b.lon, p);

  // Move vehicle
  mover.setLatLng([lat, lon]);
  mover.setStyle({
    color: speedToColor(lerp(a.speedKph || 0, b.speedKph || 0, p), maxSpeedKph)
  });

  // Follow map if enabled
  if (q("#chkFollow").checked) {
    map.panTo([lat, lon], { animate: false });
  }

  // Trail up to this point
  const upto = pts.slice(0, idx + 1).map(pt => [pt.lat, pt.lon]);
  if (upto.length) {
    upto.push([lat, lon]);
    trail.setStyle({ color: "var(--brand)" });
    trail.setLatLngs(upto);
  }

  // Scrubber and time
  const frac = (t - dataset.t0) / (dataset.t1 - dataset.t0 || 1);
  q("#scrub").value = String(Math.round(frac * 1000));
  q("#tCur").textContent = new Date(t).toLocaleTimeString();
}


/* ------------------------------------------------------------
   5. Drag-and-drop zone
   ------------------------------------------------------------ */
function enableDrop() {
  const box = document.getElementById("drop");
  if (!box) return;

  ["dragover", "dragenter"].forEach(ev =>
    box.addEventListener(ev, e => {
      e.preventDefault();
      box.style.borderColor = "var(--brand)";
    })
  );

  ["dragleave", "drop"].forEach(ev =>
    box.addEventListener(ev, e => {
      e.preventDefault();
      box.style.borderColor = "#2b3246";
    })
  );

  box.addEventListener("drop", async e => {
    const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
    if (!f) return;
    try {
      const rows = await parseFile(f);
      const ds = normalizeRows(rows);
      detectDrivingEvents(ds);
      detectFenceEvents(ds);
      applyDataset(ds);
      setPlaying(true);
    } catch (err) {
      console.error(err);
      toast("Could not read file: " + err.message);
    }
  });
}


/* ------------------------------------------------------------
   6. UI wiring
   ------------------------------------------------------------ */
document.addEventListener("DOMContentLoaded", () => {
  /* --- Dropzone --- */
  enableDrop();

  /* --- File buttons --- */
  const fileInput = q("#fileData");

  q("#btnPick").addEventListener("click", () => fileInput.click());
  q("#btnUpload").addEventListener("click", () => fileInput.click());

  fileInput.addEventListener("change", async e => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;

    try {
      const rows = await parseFile(f);
      const ds = normalizeRows(rows);
      detectDrivingEvents(ds);
      detectFenceEvents(ds);
      applyDataset(ds);
      setPlaying(true);
    } catch (err) {
      console.error(err);
      toast("Could not read file: " + err.message);
    } finally {
      e.target.value = "";
    }
  });

  /* --- Demo buttons --- */
  q("#btnQuickDemo").addEventListener("click", () => {
    const ds = normalizeRows(demoRows());
    detectDrivingEvents(ds);
    detectFenceEvents(ds);
    applyDataset(ds);
    setPlaying(true);
  });

  q("#btnDemo").addEventListener("click", () => {
    q("#btnQuickDemo").click();
  });

  /* --- Summary / Events panels --- */
  q("#btnSummaryPanel").addEventListener("click", () => {
    const p = q("#summaryPanel");
    p.style.display =
      p.style.display === "none" || !p.style.display ? "block" : "none";
  });

  q("#btnCloseSummary").addEventListener("click", () => {
    q("#summaryPanel").style.display = "none";
  });

  q("#btnEventsPanel").addEventListener("click", () => {
    const p = q("#eventsPanel");
    p.style.display =
      p.style.display === "none" || !p.style.display ? "block" : "none";
  });

  q("#btnClosePanel").addEventListener("click", () => {
    q("#eventsPanel").style.display = "none";
  });

  /* --- Event filters --- */
  ["fCrash", "fBrake", "fAccel", "fCorner", "fEnter", "fExit"].forEach(id => {
    const el = q("#" + id);
    if (!el) return;
    el.addEventListener("change", () => {
      if (typeof renderEventList === "function") renderEventList();
    });
  });

  /* --- Units & playback controls --- */
  q("#selUnits").addEventListener("change", e => {
    displayUnit = e.target.value;
    if (typeof updateStats === "function") updateStats(dataset);
    if (typeof renderEventList === "function") renderEventList();
    if (typeof updateSummaryUI === "function") updateSummaryUI();
    if (dataset) drawAll(dataset);
  });

  q("#btnPlay").addEventListener("click", () => setPlaying(true));
  q("#btnPause").addEventListener("click", () => setPlaying(false));

  q("#selRate").addEventListener("change", e => {
    rate = Number(e.target.value) || 1;
  });

  q("#chkEvents").addEventListener("change", () => {
    if (dataset) drawAll(dataset);
  });

  q("#scrub").addEventListener("input", e => {
    if (!dataset) return;
    const f = Number(e.target.value) / 1000;
    const t = dataset.t0 + f * (dataset.t1 - dataset.t0);
    playMs = t;
    const idx = findIndex(dataset.points, t);
    renderAt(idx, t);
  });

  /* --- Keyboard shortcuts --- */
  window.addEventListener("keydown", e => {
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;

    if (e.code === "Space") {
      e.preventDefault();
      if (!dataset) return;
      setPlaying(!play);
    } else if (e.code === "ArrowLeft" && dataset) {
      e.preventDefault();
      playMs = Math.max(dataset.t0, playMs - 1000);
      const idx = findIndex(dataset.points, playMs);
      renderAt(idx, playMs);
    } else if (e.code === "ArrowRight" && dataset) {
      e.preventDefault();
      playMs = Math.min(dataset.t1, playMs + 1000);
      const idx = findIndex(dataset.points, playMs);
      renderAt(idx, playMs);
    }
  });

  /* --- Export buttons --- */
  const btnExportEvents = q("#btnExportEvents");
  if (btnExportEvents && typeof exportEventsCSV === "function") {
    btnExportEvents.addEventListener("click", exportEventsCSV);
  }

  const btnExportSummary = q("#btnExportSummary");
  if (btnExportSummary) {
    btnExportSummary.addEventListener("click", () => {
      const s = typeof computeSummaryAndRisk === "function"
        ? computeSummaryAndRisk()
        : null;

      if (!s) {
        toast("Nothing to export yet.");
        return;
      }

      const header = [
        "distance_km",
        "duration_s",
        "avg_kph",
        "max_kph",
        "max_acc_mps2",
        "max_decel_mps2",
        "max_acc_g",
        "max_decel_g",
        "crash",
        "brake_harsh",
        "accel_hard",
        "corner_hard",
        "risk_score"
      ];

      const line = [
        s.distanceKm.toFixed(3),
        s.durationSec.toFixed(0),
        s.avgKph.toFixed(2),
        s.maxKph.toFixed(2),
        s.maxAcc.toFixed(3),
        s.maxDecel.toFixed(3),
        s.maxAccG.toFixed(3),
        s.maxDecelG.toFixed(3),
        s.counts.crash,
        s.counts.brake_harsh,
        s.counts.accel_hard,
        s.counts.corner_hard,
        s.risk.score.toFixed(1)
      ];

      const csv = [header.join(","), line.join(",")].join("\n");
      const a = document.createElement("a");
      a.href = URL.createObjectURL(
        new Blob([csv], { type: "text/csv;charset=utf-8;" })
      );
      a.download = "DLB_Summary.csv";
      a.click();
      URL.revokeObjectURL(a.href);
    });
  }
});
      /* ============================================================
   BLOCK 7 — FINAL BOOTSTRAP, GLOBAL FIXES, AND SAFE INITIALISATION
   ============================================================ */

/* ------------------------------------------------------------
   1. Ensure globals exist
   ------------------------------------------------------------ */

window.dataset = window.dataset || null;
window.map = window.map || null;

/* ------------------------------------------------------------
   2. Ensure drawAll() exists (fallback)
   ------------------------------------------------------------ */
if (typeof drawAll !== "function") {
  window.drawAll = function(ds) {
    if (!ds || !ds.points) return;

    if (typeof drawRoute === "function") drawRoute(ds);
    if (typeof drawEvents === "function") drawEvents();
  };
}

/* ------------------------------------------------------------
   3. Prevent double map initialisation
   ------------------------------------------------------------ */
if (!window._dlbMapInit) window._dlbMapInit = false;

function safeInitMap() {
  if (window._dlbMapInit) return;
  window._dlbMapInit = true;

  try {
    initMap();      // Your Block 1 map builder
  } catch (e) {
    console.error("Map failed initialisation:", e);
  }
}

/* ------------------------------------------------------------
   4. Boot once the DOM is ready & Leaflet is loaded
   ------------------------------------------------------------ */

function whenReady(fn) {
  if (document.readyState === "complete" || document.readyState === "interactive")
    return fn();
  document.addEventListener("DOMContentLoaded", fn);
}

function whenLeafletReady(fn) {
  if (window.L) return fn();
  const chk = setInterval(() => {
    if (window.L) {
      clearInterval(chk);
      fn();
    }
  }, 50);
}

whenReady(() =>
  whenLeafletReady(() => {
    safeInitMap();
  })
);

/* ------------------------------------------------------------
   5. Sanity guard — remove stray layers before use
   ------------------------------------------------------------ */
function cleanLayers() {
  try {
    if (!window.map) return;
    if (window.routeLayer && !map.hasLayer(routeLayer)) routeLayer.addTo(map);
    if (window.eventLayer && !map.hasLayer(eventLayer)) eventLayer.addTo(map);
    if (window.drawnItems && !map.hasLayer(drawnItems)) drawnItems.addTo(map);
  } catch (e) {
    console.warn("Layer cleanup skipped:", e);
  }
}

/* ------------------------------------------------------------
   6. High-frequency watchdog preventing “map undefined”
   ------------------------------------------------------------ */
setTimeout(cleanLayers, 300);
setTimeout(cleanLayers, 1500);
setTimeout(cleanLayers, 3000);

/* ------------------------------------------------------------
   7. Auto-recover playback after UI reloads
   ------------------------------------------------------------ */
document.addEventListener("visibilitychange", () => {
  if (!dataset || !map) return;

  // Fix leaflet viewport breaks after Chrome tab restore
  try {
    map.invalidateSize();
    if (trail) trail.redraw?.();
  } catch (e) {}

  // If tab was backgrounded while playing, resume smoothly
  if (play) {
    lastTs = 0;          // force synchronous tick restart
    requestAnimationFrame(tick);
  }
});

/* ------------------------------------------------------------
   8. Safe reflow when panels open/close
   ------------------------------------------------------------ */
["summaryPanel", "eventsPanel"].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;

  const observer = new MutationObserver(() => {
    try {
      if (map) map.invalidateSize();
    } catch (e) {}
  });

  observer.observe(el, { attributes: true, attributeFilter: ["style"] });
});
    /* ============================================================
   BLOCK 8 — DLB ADVANCED RISK ENGINE v1.0
   ============================================================ */

/*
   This engine produces:

   risk = {
     total: Number(0–100),
     behaviour: Number,
     integrity: Number,
     narrative: Number,
     spatial: Number,
     crash: Number,
     explain: [ ...strings ]
   }

   It is designed for insurance investigations.
*/


/* ------------------------------------------------------------
   1. Behaviour Score: braking, accel, cornering, repeated events
   ------------------------------------------------------------ */
function scoreBehaviour(ds) {
  if (!ds || !ds.points) return { score: 0, notes: [] };

  let brake = 0, accel = 0, corner = 0, crash = 0;
  let notes = [];

  ds.points.forEach(p => {
    (p.events || []).forEach(ev => {
      if (ev === "brake_harsh") brake++;
      if (ev === "accel_hard") accel++;
      if (ev === "corner_hard") corner++;
      if (ev === "crash") crash++;
    });
  });

  // Weighted points
  let score =
      brake * 2 +
      accel * 1.5 +
      corner * 1.75 +
      crash * 25;     // crashes dominate risk

  if (brake > 8) notes.push("Repeated harsh braking — unusual driving pattern");
  if (accel > 8) notes.push("Frequent hard acceleration — possibly aggressive use");
  if (corner > 6) notes.push("High number of hard corner events");
  if (crash > 0) notes.push("Crash-level ΔV detected in telematics");

  score = Math.min(40, score); // behaviour max 40 pts

  return { score, notes };
}


/* ------------------------------------------------------------
   2. Integrity Score (tampering / missing data / gaps / noise)
   ------------------------------------------------------------ */
function scoreIntegrity(ds) {
  if (!ds || !ds.points) return { score: 0, notes: [] };

  let notes = [];
  let gaps = 0;
  let majorGaps = 0;

  for (let i = 1; i < ds.points.length; i++) {
    const dt = (ds.points[i].t - ds.points[i-1].t) / 1000;

    if (dt >= 10 && dt < 60) gaps++;
    if (dt >= 60) majorGaps++;
  }

  let score = gaps * 1.5 + majorGaps * 6;
  if (gaps > 0) notes.push(`Missing short segments: ${gaps} gaps`);
  if (majorGaps > 0) notes.push(`Major missing time: ${majorGaps} long gaps (>60s)`);

  score = Math.min(25, score);

  return { score, notes };
}


/* ------------------------------------------------------------
   3. Narrative Score (claim vs telematics mismatch)
   ------------------------------------------------------------ */
function scoreNarrativeMisalignment(ds, claim = null) {
  /*
     claim = {
       expectedTime: unix timestamp,
       expectedLat: number,
       expectedLon: number
     }
  */

  if (!ds || !ds.points || !claim) return { score: 0, notes: [] };

  let notes = [];

  // Find nearest telematics timestamp
  let bestIdx = 0;
  let bestDt = Infinity;

  for (let i = 0; i < ds.points.length; i++) {
    const dt = Math.abs(ds.points[i].t - claim.expectedTime);
    if (dt < bestDt) {
      bestDt = dt;
      bestIdx = i;
    }
  }

  const nearest = ds.points[bestIdx];

  // Time deviation
  const timeDiff = Math.abs(nearest.t - claim.expectedTime) / 1000;

  // Distance deviation (Haversine)
  const dist = kmBetween(
    { lat: nearest.lat, lon: nearest.lon },
    { lat: claim.expectedLat, lon: claim.expectedLon }
  ) * 1000;

  let score = 0;

  if (timeDiff > 30) {
    score += 10;
    notes.push(`Claimed time differs by ${timeDiff.toFixed(0)} seconds`);
  }
  if (timeDiff > 120) {
    score += 20;
    notes.push("Large mismatch between claim time and telematics");
  }

  if (dist > 30) {
    score += 15;
    notes.push(`Location mismatch: ${dist.toFixed(1)} metres`);
  }
  if (dist > 100) {
    score += 25;
    notes.push("Telematics does not support claimed collision location");
  }

  score = Math.min(30, score);

  return { score, notes };
}


/* ------------------------------------------------------------
   4. Spatial Score (AOI, geofences, unusual behaviour)
   ------------------------------------------------------------ */
function scoreSpatial(ds, geofences, AOIs = []) {
  if (!ds || !ds.points) return { score: 0, notes: [] };

  let notes = [];
  let enters = 0;
  let exits = 0;
  let visits = 0;

  ds.points.forEach(p => {
    (p.events || []).forEach(ev => {
      if (ev.startsWith("enter:")) enters++;
      if (ev.startsWith("exit:")) exits++;
      if (ev.startsWith("stop:")) visits++;
    });
  });

  let score = 0;

  if (enters > 0) {
    score += enters * 2;
    notes.push(`${enters} entries into geofenced zones`);
  }
  if (visits > 0) {
    score += visits * 4;
    notes.push("Stops/dwells detected near AOIs or geofences");
  }

  score = Math.min(20, score);

  return { score, notes };
}


/* ------------------------------------------------------------
   5. Crash Plausibility (ΔV, pre-crash behaviour, unrealistic motion)
   ------------------------------------------------------------ */
function scoreCrashPlausibility(ds) {
  if (!ds || !ds.points) return { score: 0, notes: [] };

  let notes = [];
  let hardBrakes = 0;
  let crashes = 0;

  ds.points.forEach(p => {
    (p.events || []).forEach(ev => {
      if (ev === "crash") crashes++;
      if (ev === "brake_harsh") hardBrakes++;
    });
  });

  let score = 0;

  // Crash present but *no* harsh brake before it → suspicious
  if (crashes > 0 && hardBrakes === 0) {
    score += 15;
    notes.push("Crash detected without pre-impact deceleration — unusual");
  }

  if (crashes > 1) {
    score += 20;
    notes.push("Multiple crash signatures — possible device artefact or manipulation");
  }

  score = Math.min(20, score);

  return { score, notes };
}


/* ------------------------------------------------------------
   6. MASTER RISK CALCULATION
   ------------------------------------------------------------ */
function computeDLBRisk(ds, claim = null, AOIs = []) {
  if (!ds || !ds.points) return null;

  const behaviour = scoreBehaviour(ds);
  const integrity = scoreIntegrity(ds);
  const narrative = scoreNarrativeMisalignment(ds, claim);
  const spatial = scoreSpatial(ds, geofences, AOIs);
  const crash = scoreCrashPlausibility(ds);

  const total =
    behaviour.score +
    integrity.score +
    narrative.score +
    spatial.score +
    crash.score;

  return {
    total: Math.min(100, total),
    behaviour: behaviour.score,
    integrity: integrity.score,
    narrative: narrative.score,
    spatial: spatial.score,
    crash: crash.score,

    explain: [
      ...behaviour.notes,
      ...integrity.notes,
      ...narrative.notes,
      ...spatial.notes,
      ...crash.notes
    ]
  };
}


/* ------------------------------------------------------------
   7. Auto-update UI badge after dataset load
   ------------------------------------------------------------ */
function updateDLBRiskUI(ds) {
  const risk = computeDLBRisk(ds);
  if (!risk) return;

  const badge = q("#riskBadge");
  const dot = q("#riskDot");
  const txt = q("#riskText");

  badge.style.display = "flex";

  let colour = "var(--ok)";
  if (risk.total >= 70) colour = "var(--bad)";
  else if (risk.total >= 40) colour = "var(--warn)";

  dot.style.background = colour;
  txt.textContent = `Risk: ${risk.total.toFixed(0)}`;

  // Optionally inject a detailed explanation somewhere later
  console.log("DLB Risk Details:", risk);
}
     /* ============================================================
   BLOCK 9 — Commercial Packaging & Public API
   Versioning, hardening, and a clean external interface
   ============================================================ */

const DLB_PLAYER_VERSION = "1.0.0";

/**
 * Lightweight health check – can be called by host app.
 */
function dlbHealthCheck() {
  return {
    ok: !!(window.L && window.Papa && window.XLSX && window.turf),
    leaflet: !!window.L,
    papaparse: !!window.Papa,
    xlsx: !!window.XLSX,
    turf: !!window.turf,
    version: DLB_PLAYER_VERSION
  };
}

/* ------------------------------------------------------------
   Global error logging hook (non-fatal, for future wiring)
   ------------------------------------------------------------ */
window.addEventListener("error", (ev) => {
  try {
    console.warn("[DLB Player] JS error caught:", ev.message, ev.filename, ev.lineno);
  } catch (e) {
    // swallow – never break the UI from logging
  }
});

/* ------------------------------------------------------------
   Public API surface for host systems
   Exposed under window.DLBTelematicsPlayer
   ------------------------------------------------------------ */

(function initDLBPublicAPI() {
  // Ensure we don’t overwrite if embedded twice
  if (window.DLBTelematicsPlayer) return;

  /**
   * Internal helper: normalise + apply rows and start playback.
   * Used by both file + direct-row loaders.
   */
  function _mountFromRows(rows, autoPlay = true) {
    if (!rows || !rows.length) {
      toast("No rows supplied to DLBTelematicsPlayer.mountFromRows");
      return null;
    }
    const ds = normalizeRows(rows);
    applyDataset(ds);
    if (autoPlay) setPlaying(true);
    return ds;
  }

  /**
   * Internal helper: load from a File object (CSV/XLSX).
   */
  async function _mountFromFile(file, autoPlay = true) {
    if (!file) {
      toast("No file supplied to DLBTelematicsPlayer.mountFromFile");
      return null;
    }
    const rows = await parseFile(file);
    return _mountFromRows(rows, autoPlay);
  }

  /**
   * Export summary CSV based on current summaryCache.
   * (Mirrors your existing Export Summary button.)
   */
  function _exportSummaryCsv() {
    if (!summaryCache) {
      toast("Nothing to export");
      return;
    }
    const s = summaryCache;
    const header = [
      "distance_km",
      "duration_s",
      "avg_kph",
      "max_kph",
      "max_acc_mps2",
      "max_decel_mps2",
      "max_acc_g",
      "max_decel_g",
      "crash",
      "brake_harsh",
      "accel_hard",
      "corner_hard",
      "risk_score"
    ];
    const line = [
      s.distanceKm.toFixed(3),
      s.durationSec.toFixed(0),
      s.avgKph.toFixed(2),
      s.maxKph.toFixed(2),
      s.maxAcc.toFixed(3),
      s.maxDecel.toFixed(3),
      s.maxAccG.toFixed(3),
      s.maxDecelG.toFixed(3),
      s.counts.crash,
      s.counts.brake_harsh,
      s.counts.accel_hard,
      s.counts.corner_hard,
      s.risk.score.toFixed(1)
    ];
    dl("summary.csv", [header.join(","), line.join(",")].join("\n"), "text/csv");
  }

  /**
   * Public object: attach everything we want to expose.
   * This is what you "sell" / integrate with portals / claim tools.
   */
  window.DLBTelematicsPlayer = {
    version: DLB_PLAYER_VERSION,

    // Health / environment
    health: dlbHealthCheck,

    // Core mounting
    mountFromFile: _mountFromFile,   // async (File, autoPlay=true) -> dataset
    mountFromRows: _mountFromRows,   // (rows[], autoPlay=true) -> dataset

    // Accessors
    getDataset: () => dataset,
    getSummary: () => summaryCache,
    getRisk: () => (dataset ? computeDLBRisk(dataset) : null),

    // Exports
    exportSummaryCsv: _exportSummaryCsv,
    exportEventsCsv: exportEventsCSV,

    // Playback control (for host UIs if needed)
    play: () => setPlaying(true),
    pause: () => setPlaying(false),
    seekFraction: (f) => {
      if (!dataset || typeof f !== "number") return;
      f = Math.max(0, Math.min(1, f));
      const t = dataset.t0 + f * (dataset.t1 - dataset.t0);
      playMs = t;
      const idx = findIndex(dataset.points, t);
      renderAt(idx, t);
      q("#scrub").value = String(Math.round(f * 1000));
    }
  };

  console.log(
    `%cDLB Telematics Player v${DLB_PLAYER_VERSION} ready`,
    "color:#1fb6ff;font-weight:bold;"
  );
})();
     
        
